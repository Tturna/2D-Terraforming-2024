#pragma kernel cs_main

struct mesh_triangle
{
    float2 vertex_a;
    float2 vertex_b;
    float2 vertex_c;
};

struct mesh_edge
{
    float2 vertex_a;
    float2 vertex_b;
};

int res;
float iso_value;
int chunks_per_side;
int chunk_x;
int chunk_y;

RWTexture2D<float> point_map;
AppendStructuredBuffer<mesh_triangle> triangles;
AppendStructuredBuffer<mesh_edge> boundary_edges;

/*
 *      3 - (6) - 2
 *      |         |
 *     (7)       (5)
 *      |         |
 *      0 - (4) - 1
 */
     
static int tri_table[15][12] = {
    { 0, 3, 2, 0, 2, 1, -1, -1, -1, -1, -1, -1 },
    { 7, 3, 2, 4, 7, 2, 1, 4, 2, -1, -1, -1 },
    { 4, 0, 3, 5, 4, 3, 2, 5, 3, -1, -1, -1 },
    { 7, 3, 2, 7, 2, 5, -1, -1, -1, -1, -1, -1, },
    { 5, 1, 0, 6, 5, 0, 3, 6, 0, -1, -1, -1 },
    { 7, 3, 6, 4, 7, 6, 4, 6, 5, 5, 1, 4 },
    { 4, 0, 3, 4, 3, 6, -1, -1, -1, -1, -1, -1 },
    { 7, 3, 6, -1, -1, -1, -1, -1, -1, -1, -1, -1 },
    { 6, 2, 1, 1, 0, 7, 7, 6, 1, -1, -1, -1 },
    { 6, 2, 1, 6, 1, 4, -1, -1, -1, -1, -1, -1 },
    { 0, 7, 4, 7, 6, 4, 6, 5, 4, 6, 2, 5 },
    { 6, 2, 5, -1, -1, -1, -1, -1, -1, -1, -1, -1 },
    { 5, 1, 0, 5, 0, 7, -1, -1, -1, -1, -1, -1 },
    { 5, 1, 4, -1, -1, -1, -1, -1, -1, -1, -1, -1 },
    { 7, 4, 0, -1, -1, -1, -1, -1, -1, -1, -1, -1 }
};

static int boundary_vertex_index_table[14][4] = {
    { 4, 7, -1, -1 },
    { 5, 4, -1, -1 },
    { 5, 7, -1, -1 },
    { 6, 5, -1, -1 },
    { 6, 5, 4, 7},
    { 6, 4, -1, -1 },
    { 6, 7, -1, -1},
    { 7, 6, -1, -1 },
    { 4, 6, -1, -1 },
    { 7, 6, 5, 4 },
    { 5, 6, -1, -1 },
    { 7, 5, -1, -1 },
    { 4, 5, -1, -1 },
    { 7, 4, -1, -1 }
};

float inverse_lerp(const float a, const float b, const float v)
{
    return clamp((v - a) / (b - a), 0.0, 1.0);
}

[numthreads(16, 16, 1)]  
void cs_main (uint3 id : SV_DispatchThreadID)
{
    // each thread processes a cell in a chunk, so we need to skip the last row and column
    if (id.x == res - 1 || id.y == res - 1) return;

    const float chunk_w = float(res) / float(chunks_per_side);
    const float2 chunk_offset = float2(chunk_x * chunk_w, chunk_y * chunk_w);
    const float2 offset = float2(id.x + chunk_offset.x, id.y + chunk_offset.y);

    const float bl = 1.0 - point_map[offset];
    const float br = 1.0 - point_map[offset + float2(1, 0)];
    const float tl = 1.0 - point_map[offset + float2(0, 1)];
    const float tr = 1.0 - point_map[offset + float2(1, 1)];

    const int bl_bin = bl > iso_value ? 1 : 0;
    const int br_bin = br > iso_value ? 1 : 0;
    const int tl_bin = tl > iso_value ? 1 : 0;
    const int tr_bin = tr > iso_value ? 1 : 0;

    int config = 0;
    config |= 1 * bl_bin;
    config |= 2 * br_bin;
    config |= 4 * tr_bin;
    config |= 8 * tl_bin;

    // skip if the cell is empty
    if (config == 15) return;
    
    const float bottom_edge_iso_lerp = inverse_lerp(bl, br, iso_value);
    const float right_edge_iso_lerp = inverse_lerp(br, tr, iso_value);
    const float top_edge_iso_lerp = inverse_lerp(tl, tr, iso_value);
    const float left_edge_iso_lerp = inverse_lerp(bl, tl, iso_value);
    
    // const float bottom_edge_iso_lerp = 0.5;
    // const float right_edge_iso_lerp = 0.5;
    // const float top_edge_iso_lerp = 0.5;
    // const float left_edge_iso_lerp = 0.5;

    const float x = id.x + chunk_offset.x;
    const float y = id.y + chunk_offset.y;

    const float2 cell_vertices[8] = {
        float2(x, y),
        float2(x + 1, y),
        float2(x + 1, y + 1),
        float2(x, y + 1),
        float2(x + bottom_edge_iso_lerp, y),
        float2(x + 1, y + right_edge_iso_lerp),
        float2(x + top_edge_iso_lerp, y + 1),
        float2(x, y + left_edge_iso_lerp)
    };

    const int tris[12] = tri_table[config];
    
    for (int i = 0; i < 12; i += 3)
    {
        if (tris[i] == -1) break;

        mesh_triangle tri;
        tri.vertex_a = cell_vertices[tris[i]];
        tri.vertex_b = cell_vertices[tris[i + 1]];
        tri.vertex_c = cell_vertices[tris[i + 2]];
        triangles.Append(tri);

        if (config != 0)
        {
            const int boundary_vertex_indices[4] = boundary_vertex_index_table[config - 1];

            for (int j = 0; j < 4; j += 2)
            {
                if (boundary_vertex_indices[j] == -1) break;

                mesh_edge edge;
                edge.vertex_a = cell_vertices[boundary_vertex_indices[j]];
                edge.vertex_b = cell_vertices[boundary_vertex_indices[j + 1]];

                boundary_edges.Append(edge);
            }
        }
    }
}