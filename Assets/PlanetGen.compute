#pragma kernel cs_main

struct mesh_triangle
{
    float2 vertex_a;
    float2 vertex_b;
    float2 vertex_c;
};

int res;
float iso_value;
int chunks_per_side;
int chunk_x;
int chunk_y;
float noise_scale;
float noise_offset_x;
float noise_offset_y;

AppendStructuredBuffer<mesh_triangle> inner_triangles;
AppendStructuredBuffer<mesh_triangle> outer_triangles;

/*
 *      3 - (6) - 2
 *      |         |
 *     (7)       (5)
 *      |         |
 *      0 - (4) - 1
 */
     
static int tri_table[15][12] = {
    { 0, 3, 2, 0, 2, 1, -1, -1, -1, -1, -1, -1 },
    { 7, 3, 2, 4, 7, 2, 1, 4, 2, -1, -1, -1 },
    { 4, 0, 3, 5, 4, 3, 2, 5, 3, -1, -1, -1 },
    { 7, 3, 2, 7, 2, 5, -1, -1, -1, -1, -1, -1, },
    { 5, 1, 0, 6, 5, 0, 3, 6, 0, -1, -1, -1 },
    { 7, 3, 6, 4, 7, 6, 4, 6, 5, 5, 1, 4 },
    { 4, 0, 3, 4, 3, 6, -1, -1, -1, -1, -1, -1 },
    { 7, 3, 6, -1, -1, -1, -1, -1, -1, -1, -1, -1 },
    { 6, 2, 1, 1, 0, 7, 7, 6, 1, -1, -1, -1 },
    { 6, 2, 1, 6, 1, 4, -1, -1, -1, -1, -1, -1 },
    { 0, 7, 4, 7, 6, 4, 6, 5, 4, 6, 2, 5 },
    { 6, 2, 5, -1, -1, -1, -1, -1, -1, -1, -1, -1 },
    { 5, 1, 0, 5, 0, 7, -1, -1, -1, -1, -1, -1 },
    { 5, 1, 4, -1, -1, -1, -1, -1, -1, -1, -1, -1 },
    { 7, 4, 0, -1, -1, -1, -1, -1, -1, -1, -1, -1 }
};

float inverse_lerp(const float a, const float b, const float v)
{
    return clamp((v - a) / (b - a), 0.0, 1.0);
}

// Unity's noise functions ------------------------------------------------------------------------
float2 unity_gradient_noise_dir(float2 p)
{
    p = p % 289;
    float x = (34 * p.x + 1) * p.x % 289 + p.y;
    x = (34 * x + 1) * x % 289;
    x = frac(x / 41) * 2 - 1;
    return normalize(float2(x - floor(x + 0.5), abs(x) - 0.5));
}

float unity_gradient_noise(float2 p)
{
    const float2 ip = floor(p);
    float2 fp = frac(p);
    const float d00 = dot(unity_gradient_noise_dir(ip), fp);
    const float d01 = dot(unity_gradient_noise_dir(ip + float2(0, 1)), fp - float2(0, 1));
    const float d10 = dot(unity_gradient_noise_dir(ip + float2(1, 0)), fp - float2(1, 0));
    const float d11 = dot(unity_gradient_noise_dir(ip + float2(1, 1)), fp - float2(1, 1));
    fp = fp * fp * fp * (fp * (fp * 6 - 15) + 10);
    return lerp(lerp(d00, d01, fp.y), lerp(d10, d11, fp.y), fp.x);
}

float unity_gradient_noise_float(const float2 uv, const float scale)
{
    return unity_gradient_noise(uv * scale) + 0.5;
}
// Unity's noise functions ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  
[numthreads(16, 16, 1)]  
void cs_main (uint3 id : SV_DispatchThreadID)
{
    // each thread processes a cell in a chunk, so we need to skip the last row and column
    if (id.x == res - 1 || id.y == res - 1) return;

    const float chunk_w = float(res) / float(chunks_per_side);
    const float2 offset = float2(id.x + noise_offset_x, id.y + noise_offset_y);
    const float2 chunk_offset = float2(chunk_x * chunk_w, chunk_y * chunk_w);
    const float2 noise_uv = float2((offset.x + chunk_offset.x) / res, (offset.y + chunk_offset.y) / res);
    const float unit = 1.0 / float(res);
    
    const float bl = unity_gradient_noise_float(noise_uv, noise_scale);
    const float br = unity_gradient_noise_float(noise_uv + float2(unit, 0), noise_scale);
    const float tl = unity_gradient_noise_float(noise_uv + float2(0, unit), noise_scale);
    const float tr = unity_gradient_noise_float(noise_uv + unit.xx, noise_scale);

    const int bl_bin = bl > iso_value ? 1 : 0;
    const int br_bin = br > iso_value ? 1 : 0;
    const int tl_bin = tl > iso_value ? 1 : 0;
    const int tr_bin = tr > iso_value ? 1 : 0;

    int config = 0;
    config |= 1 * bl_bin;
    config |= 2 * br_bin;
    config |= 4 * tr_bin;
    config |= 8 * tl_bin;

    // skip if the cell is empty
    if (config == 15) return;
    
    const float bottom_edge_iso_lerp = inverse_lerp(bl, br, iso_value);
    const float right_edge_iso_lerp = inverse_lerp(br, tr, iso_value);
    const float top_edge_iso_lerp = inverse_lerp(tl, tr, iso_value);
    const float left_edge_iso_lerp = inverse_lerp(bl, tl, iso_value);
    
    // const float bottom_edge_iso_lerp = 0.5;
    // const float right_edge_iso_lerp = 0.5;
    // const float top_edge_iso_lerp = 0.5;
    // const float left_edge_iso_lerp = 0.5;

    const float x = id.x + chunk_offset.x;
    const float y = id.y + chunk_offset.y;

    const float2 cell_vertices[8] = {
        float2(x, y),
        float2(x + 1, y),
        float2(x + 1, y + 1),
        float2(x, y + 1),
        float2(x + bottom_edge_iso_lerp, y),
        float2(x + 1, y + right_edge_iso_lerp),
        float2(x + top_edge_iso_lerp, y + 1),
        float2(x, y + left_edge_iso_lerp)
    };

    const int tris[12] = tri_table[config];
    
    for (int i = 0; i < 12; i += 3)
    {
        if (tris[i] == -1) break;

        mesh_triangle tri;
        tri.vertex_a = cell_vertices[tris[i]];
        tri.vertex_b = cell_vertices[tris[i + 1]];
        tri.vertex_c = cell_vertices[tris[i + 2]];

        if (config == 0)
        {
            inner_triangles.Append(tri);
        }
        else
        {
            outer_triangles.Append(tri);
        }
    }
}