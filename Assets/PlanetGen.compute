#pragma kernel cs_main

struct mesh_triangle
{
    float2 vertex_a;
    float2 vertex_b;
    float2 vertex_c;
};

Texture2D source;
SamplerState pointClampSampler;
// RWTexture2D<float4> result;
float resolution;
float iso_value;
float noise_scale;
float noise_offset_x;
float noise_offset_y;

// RWStructuredBuffer<float2> vertices;
AppendStructuredBuffer<mesh_triangle> triangles;

/*
 *      3 - (6) - 2
 *      |         |
 *     (7)       (5)
 *      |         |
 *      0 - (4) - 1
 */
     
static int tri_table[15][12] = {
    { 0, 3, 2, 0, 2, 1, -1, -1, -1, -1, -1, -1 },
    { 7, 3, 2, 4, 7, 2, 1, 4, 2, -1, -1, -1 },
    { 4, 0, 3, 5, 4, 3, 2, 5, 3, -1, -1, -1 },
    { 7, 3, 2, 7, 2, 5, -1, -1, -1, -1, -1, -1, },
    { 5, 1, 0, 6, 5, 0, 3, 6, 0, -1, -1, -1 },
    { 7, 3, 6, 4, 7, 6, 4, 6, 5, 5, 1, 4 },
    { 4, 0, 3, 4, 3, 6, -1, -1, -1, -1, -1, -1 },
    { 7, 3, 6, -1, -1, -1, -1, -1, -1, -1, -1, -1 },
    { 6, 2, 1, 1, 0, 7, 7, 6, 1, -1, -1, -1 },
    { 6, 2, 1, 6, 1, 4, -1, -1, -1, -1, -1, -1 },
    { 0, 7, 4, 7, 6, 4, 6, 5, 4, 6, 2, 5 },
    { 6, 2, 5, -1, -1, -1, -1, -1, -1, -1, -1, -1 },
    { 5, 1, 0, 5, 0, 7, -1, -1, -1, -1, -1, -1 },
    { 5, 1, 4, -1, -1, -1, -1, -1, -1, -1, -1, -1 },
    { 7, 4, 0, -1, -1, -1, -1, -1, -1, -1, -1, -1 }
};

float inverse_lerp(const float a, const float b, const float v)
{
    return clamp((v - a) / (b - a), 0.0, 1.0);
}

// Unity's noise functions ------------------------------------------------------------------------
float2 unity_gradient_noise_dir(float2 p)
{
    p = p % 289;
    float x = (34 * p.x + 1) * p.x % 289 + p.y;
    x = (34 * x + 1) * x % 289;
    x = frac(x / 41) * 2 - 1;
    return normalize(float2(x - floor(x + 0.5), abs(x) - 0.5));
}

float unity_gradient_noise(float2 p)
{
    const float2 ip = floor(p);
    float2 fp = frac(p);
    const float d00 = dot(unity_gradient_noise_dir(ip), fp);
    const float d01 = dot(unity_gradient_noise_dir(ip + float2(0, 1)), fp - float2(0, 1));
    const float d10 = dot(unity_gradient_noise_dir(ip + float2(1, 0)), fp - float2(1, 0));
    const float d11 = dot(unity_gradient_noise_dir(ip + float2(1, 1)), fp - float2(1, 1));
    fp = fp * fp * fp * (fp * (fp * 6 - 15) + 10);
    return lerp(lerp(d00, d01, fp.y), lerp(d10, d11, fp.y), fp.x);
}

float unity_gradient_noise_float(const float2 uv, const float scale)
{
    return unity_gradient_noise(uv * scale) + 0.5;
}
// Unity's noise functions ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  
[numthreads(8,8,1)]  
void cs_main (uint3 id : SV_DispatchThreadID)
{
    // const float2 uv = float2(id.x / resolution, id.y / resolution);
    // const float4 source_color = source.SampleLevel(pointClampSampler, uv, 0);
    // result[id.xy] = float4(1.0, 0.0, 0.0, source_color.a);

    // cells = 255 * 255 because each cell is 2x2 points.
    // for now we use pixels as points because our source image already represents the points.
    // normally here you would have to create a grid and use an iso-level to determine the points.

    // for each cell, find the configuration from the tri table.
    if (id.x == resolution - 1 || id.y == 0) return;

    // Reverse because white should be terrain and black should be empty. The tri table is for the opposite.
    // const float bl = 1 - source.SampleLevel(pointClampSampler, float2(id.x / resolution, id.y / resolution), 0).a;
    // const float br = 1 - source.SampleLevel(pointClampSampler, float2((id.x + 1) / resolution, id.y / resolution), 0).a;
    // const float tl = 1 - source.SampleLevel(pointClampSampler, float2(id.x / resolution, (id.y + 1) / resolution), 0).a;
    // const float tr = 1 - source.SampleLevel(pointClampSampler, float2((id.x + 1) / resolution, (id.y + 1) / resolution), 0).a;

    const float2 noise_uv = float2((id.x + noise_offset_x) / resolution, (id.y + noise_offset_y) / resolution);
    const float unit = 1 / resolution;
    
    const float bl = unity_gradient_noise_float(noise_uv, noise_scale);
    const float br = unity_gradient_noise_float(noise_uv + float2(unit, 0), noise_scale);
    const float tl = unity_gradient_noise_float(noise_uv + float2(0, unit), noise_scale);
    const float tr = unity_gradient_noise_float(noise_uv + unit.xx, noise_scale);

    const int bl_bin = bl > iso_value ? 1 : 0;
    const int br_bin = br > iso_value ? 1 : 0;
    const int tl_bin = tl > iso_value ? 1 : 0;
    const int tr_bin = tr > iso_value ? 1 : 0;

    int config = 0;
    config |= 1 * bl_bin;
    config |= 2 * br_bin;
    config |= 4 * tr_bin;
    config |= 8 * tl_bin;

    // skip if the cell is empty
    if (config == 15) return;

    // const float2 cell_vertices[8] = {
    //     float2(id.x / resolution, id.y / resolution),
    //     float2((id.x + 1) / resolution, id.y / resolution),
    //     float2((id.x + 1) / resolution, (id.y + 1) / resolution),
    //     float2(id.x / resolution, (id.y + 1) / resolution),
    //     float2((id.x + 0.5) / resolution, id.y / resolution),
    //     float2((id.x + 1) / resolution, (id.y + 0.5) / resolution),
    //     float2((id.x + 0.5) / resolution, (id.y + 1) / resolution),
    //     float2(id.x / resolution, (id.y + 0.5) / resolution)
    // };

    const float bottom_edge_iso_lerp = inverse_lerp(bl, br, iso_value);
    const float right_edge_iso_lerp = inverse_lerp(br, tr, iso_value);
    const float top_edge_iso_lerp = inverse_lerp(tl, tr, iso_value);
    const float left_edge_iso_lerp = inverse_lerp(bl, tl, iso_value);
    
    // const float bottom_edge_iso_lerp = 0.5;
    // const float right_edge_iso_lerp = 0.5;
    // const float top_edge_iso_lerp = 0.5;
    // const float left_edge_iso_lerp = 0.5;

    const float2 cell_vertices[8] = {
        float2(id.x, id.y),
        float2(id.x + 1, id.y),
        float2(id.x + 1, id.y + 1),
        float2(id.x, id.y + 1),
        float2(id.x + bottom_edge_iso_lerp, id.y),
        float2(id.x + 1, id.y + right_edge_iso_lerp),
        float2(id.x + top_edge_iso_lerp, id.y + 1),
        float2(id.x, id.y + left_edge_iso_lerp)
    };

    const int tris[12] = tri_table[config];
    
    for (int i = 0; i < 12; i += 3)
    {
        if (tris[i] == -1) break;

        mesh_triangle tri;
        tri.vertex_a = cell_vertices[tris[i]];
        tri.vertex_b = cell_vertices[tris[i + 1]];
        tri.vertex_c = cell_vertices[tris[i + 2]];
        triangles.Append(tri);
    }
}